(define (resolve-unresolved-aggregate-deps!)
  (mibl-trace-entry "resolve-unresolved-aggregate-deps!" "")
  (for-each (lambda (ws-kv)
              ;; (format #t "ws key: ~A\n" (car ws-kv))
              (let ((pkgs (car (assoc-val :pkgs (cdr ws-kv)))))
                (for-each (lambda (pkg-kv)
                            (mibl-trace "resolving pkg" (car pkg-kv))
                            (let* ((pkg (cdr pkg-kv))
                                   (pkg-ns-lib-deps     (assoc-in '(:mibl :ns-library :deps :resolved) pkg))
                                   (pkg-ns-archive-deps (assoc-in '(:mibl :ns-archive :deps :resolved) pkg))
                                   (pkg-lib-deps        (assoc-in '(:mibl :library :deps :resolved) pkg))
                                   (pkg-archive-deps    (assoc-in '(:mibl :archive :deps :resolved) pkg)))
                              (mibl-trace "pkg-ns-lib-deps" pkg-ns-lib-deps)
                              (mibl-trace "pkg-ns-archive-deps" pkg-ns-archive-deps)
                              (mibl-trace "pkg-lib-deps" pkg-lib-deps)
                              (mibl-trace "pkg-archive-deps" pkg-archive-deps)
                              (for-each (lambda (lst)
                                          (if (truthy? lst)
                                              (let ((resolved (map (lambda (dep)
                                                                     (if (eq? :unresolved (car dep))
                                                                         `(:opam? . ,(cdr dep))
                                                                         dep))
                                                                   (cdr lst))))
                                                (mibl-trace "resolved" resolved)
                                                (set-cdr! lst resolved))))
                                        (list pkg-ns-lib-deps pkg-ns-archive-deps
                                              pkg-lib-deps pkg-archive-deps))))
                          pkgs)))
            *mibl-project*))

;; currently this just removes :unresolved deps, on the assumption
;; that such deps will be resolved by aggregate deps (dune's 'libraries').
;; enhancement: lookup such deps in opam pkgs etc.
(define (resolve-unresolved-file-deps!)
  (mibl-trace-entry "resolve-unresolved-file-deps!" "")
  ;; WARNING: if pruning results in a pair, restore the dot, e.g. (Foo . foo.ml)
  (for-each (lambda (ws-kv)
              ;; (format #t "ws key: ~A\n" (car ws-kv))
              (let ((pkgs (car (assoc-val :pkgs (cdr ws-kv)))))
                (for-each (lambda (pkg-kv)
                            (let* ((pkg (cdr pkg-kv))
                                   (pkg-modules (assoc-val :modules pkg))
                                   (pkg-structs (assoc :structures pkg))
                                   (pkg-sigs (assoc :signatures pkg)))

                              (mibl-trace "pkg-modules" pkg-modules)
                              (mibl-trace "pkg-structs" pkg-structs)
                              (mibl-trace "pkg-sigs" pkg-sigs)

                              (if (truthy? pkg-modules)
                                  (for-each (lambda (module)
                                              (mibl-trace "resolving module" module)
                                              (if-let ((ml-static (assoc :ml (cdr module))))
                                                      (if (list? (cdr ml-static))
                                                          (let* ((mibl-trace-let "ml-static" ml-static)
                                                                 (deps (cddr ml-static))
                                                                 (fixed (filter (lambda (dep)
                                                                                  (mibl-trace "dep" dep)
                                                                                  (not (eq? :unresolved (car dep))))
                                                                                deps)))
                                                            (if (truthy? fixed)
                                                                (set-cdr! (cdr ml-static) fixed)
                                                                (set-cdr! ml-static (cadr ml-static))))))
                                              (if-let ((ml-dynamic (assoc :ml_ (cdr module))))
                                                      (if (list? (cdr ml-dynamic))
                                                          (let* ((mibl-trace-let "ml-dynamic a" ml-dynamic)
                                                                 (deps (cddr ml-dynamic))
                                                                 (fixed (filter (lambda (dep)
                                                                                  (mibl-trace "dep" dep)
                                                                                  (not (eq? :unresolved (car dep))))
                                                                                deps)))
                                                            (if (truthy? fixed)
                                                                (set-cdr! (cdr ml-dynamic) fixed)
                                                                (set-cdr! ml-dynamic (cadr ml-dynamic))))))
                                                            ;; (set-cdr! (cdr ml-dynamic) fixed))))
                                              (if-let ((mli-static (assoc :mli (cdr module))))
                                                      (if (list? (cdr mli-static))
                                                          (let* ((mibl-trace-let "mli-static" mli-static)
                                                                 (deps (cddr mli-static))
                                                                 (fixed (filter (lambda (dep)
                                                                                  (mibl-trace "dep" dep)
                                                                                  (not (eq? :unresolved (car dep))))
                                                                                deps)))
                                                            (if (truthy? fixed)
                                                                (set-cdr! (cdr mli-static) fixed)
                                                                (set-cdr! mli-static (cadr mli-static))))))
                                                            ;; (set-cdr! (cdr mli-static) fixed))))
                                              (if-let ((mli-dynamic (assoc :mli_ (cdr module))))
                                                      (if (list? (cdr mli-dynamic))
                                                          (let* ((mibl-trace-let "mli-dynamic" mli-dynamic)
                                                                 (deps (cddr mli-dynamic))
                                                                 (fixed (filter (lambda (dep)
                                                                                  (mibl-trace "dep" dep)
                                                                                  (not (eq? :unresolved (car dep))))
                                                                                deps)))
                                                            (if (truthy? fixed)
                                                                (set-cdr! (cdr mli-dynamic) fixed)
                                                                (set-cdr! mli-dynamic (cadr mli-dynamic)))))))
                                            pkg-modules))

                              (if (truthy? pkg-structs)
                                  (let* ((statics (if-let ((statics (assoc-in '(:structures :static) pkg)))
                                                          statics '()))
                                         (dynamics (if-let ((dynamics (assoc-in '(:structures :dynamic) pkg)))
                                                           dynamics '())))
                                    (mibl-trace "static structs" statics)
                                    (mibl-trace "dynamic structs" dynamics)
                                    (if (truthy? statics)
                                        (for-each (lambda (struct)
                                                    (mibl-trace "resolving statstruct" struct)
                                                    (if (list? (cdr struct))
                                                        (let* ((deps (cddr struct))
                                                               (resolved (filter (lambda (dep)
                                                                                   (mibl-trace "dep" dep)
                                                                                   (not (eq? :unresolved (car dep))))
                                                                                 deps)))
                                                          (if (truthy? resolved)
                                                              (set-cdr! (cdr struct) resolved)
                                                              ;; else if nil, restore pair
                                                              (set-cdr! struct (cadr struct))))))
                                                  (cdr statics)))
                                    (if (truthy? dynamics)
                                        (for-each (lambda (struct)
                                                    (mibl-trace "resolving dynstruct" struct)
                                                    (if (list? (cdr struct))
                                                        (let* ((deps (cddr struct))
                                                               (resolved (filter (lambda (dep)
                                                                                   (mibl-trace "dep" dep)
                                                                                   (not (eq? :unresolved (car dep))))
                                                                                 deps)))
                                                          (if (truthy? resolved)
                                                              (set-cdr! (cdr struct) resolved)
                                                              ;; else if nil, restore pair
                                                              (set-cdr! struct (cadr struct))))))
                                                  (cdr dynamics)))))

                              (if pkg-sigs
                                  (let* ((statics (if-let ((statics (assoc-in '(:signatures :static) pkg)))
                                                          statics '()))
                                         (dynamics (if-let ((dynamics (assoc-in '(:signatures :dynamic) pkg)))
                                                           dynamics '())))
                                    (mibl-trace "static sigs" statics)
                                    (mibl-trace "dynamic sigs" dynamics)
                                    (if (truthy? statics)
                                        (for-each (lambda (sig)
                                                    (mibl-trace "resolving statsig" sig)
                                                    ;; e.g. (Foo foo.mli (:unresolved . Ppxlib))
                                                    (if (list? (cdr sig))
                                                        (let* ((deps (cddr sig))
                                                               (resolved (filter (lambda (dep)
                                                                                (mibl-trace "dep" dep)
                                                                                (not (eq? :unresolved (car dep))))
                                                                              deps)))
                                                          (mibl-trace "resolved" resolved)
                                                          (if (truthy? resolved)
                                                              (set-cdr! (cdr sig) resolved)
                                                              ;; else if nil, restore pair
                                                              (set-cdr! sig (cadr sig))))))
                                                  (cdr statics)))
                                    (if (truthy? dynamics)
                                        (for-each (lambda (sig)
                                                    (mibl-trace "resolving dynsig" sig)
                                                    (if (list? (cdr sig))
                                                        (let* ((deps (cddr sig))
                                                               (resolved (filter (lambda (dep)
                                                                                   (mibl-trace "dep" dep)
                                                                                   (not (eq? :unresolved (car dep))))
                                                                                 deps)))
                                                          (if (truthy? resolved)
                                                              (set-cdr! (cdr sig) resolved)
                                                              ;; else if nil, restore pair
                                                              (set-cdr! sig (cadr sig))))))
                                                  (cdr dynamics)))))
                              ))
                          pkgs)))
            *mibl-project*))

(define (resolve-unresolved-ppx-deps!)
  (mibl-trace-entry "resolve-unresolved-ppx-deps!" "")
  (for-each (lambda (ws-kv)
              ;; (format #t "ws key: ~A\n" (car ws-kv))
              (let ((pkgs (car (assoc-val :pkgs (cdr ws-kv)))))
                (for-each (lambda (pkg-kv)
                            (mibl-trace "resolving pkg" (car pkg-kv))
                            (let* ((pkg (cdr pkg-kv))
                                   (pkg-ns-lib-ppx     (assoc-in '(:mibl :ns-library :ppx :manifest) pkg))
                                   (pkg-ns-archive-ppx (assoc-in '(:mibl :ns-archive :ppx :manifest) pkg))
                                   (pkg-lib-ppx        (assoc-in '(:mibl :library :ppx :manifest) pkg))
                                   (pkg-archive-ppx    (assoc-in '(:mibl :archive :ppx :manifest) pkg)))
                              (mibl-trace "pkg-ns-lib-ppx" pkg-ns-lib-ppx)
                              (mibl-trace "pkg-ns-archive-ppx" pkg-ns-archive-ppx)
                              (mibl-trace "pkg-lib-ppx" pkg-lib-ppx)
                              (mibl-trace "pkg-archive-ppx" pkg-archive-ppx)
                              (for-each (lambda (ppx)
                                          (mibl-trace "ppx" ppx)
                                          ;; e.g. (:manifest (:local (:pkg . src) (:tgt . ppx_assert)) (:unresolved . ppx_bench))
                                          ;; e.g. (:manifest (:unresolved . ppx_jane) ...)
                                          (if (truthy? ppx)
                                              (let ((resolved (map (lambda (dep)
                                                                     (mibl-trace "ppx dep" dep)
                                                                     (if (eq? :unresolved (car dep))
                                                                         `(:opam? . ,(cdr dep))
                                                                         dep))
                                                                   (cdr ppx))))
                                                (mibl-trace "resolved" resolved)
                                                (set-cdr! ppx resolved)
                                                ;; (if (truthy? resolved)
                                                ;;     (set-cdr! ppx resolved)
                                                ;;     ;; else if nil, restore pair
                                                ;;     (set-cdr! ppx (cadr ppx)))
                                                (mibl-trace "updated ppx" ppx))))
                                        (list pkg-ns-lib-ppx pkg-ns-archive-ppx
                                              pkg-lib-ppx pkg-archive-ppx))))
                          pkgs)))
            *mibl-project*))



