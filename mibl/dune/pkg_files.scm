;; returns pair from :modules e.g. (:ml foo.ml) or (:ml_ foo.ml)
;; or (:mli foo.mli) or (:mli_ foo.mli)
(define (-find-m-file-in-pkg-modules arg pkg)
  (format #t "~A: ~A~%" (blue "find-m-file-in-pkg-modules") arg)
  (let* ((pkg-modules (if-let ((files (assoc-val :modules pkg)))
                                files '()))
         (_ (format #t "~A: ~A~%" (yellow "pkg-modules") pkg-modules))
         (m-name (filename->module-name arg))
         (_ (format #t "~A: ~A~%" (yellow "m-name") m-name))
         (file
          (find-if (lambda (mod)
                     (format #t "~A: ~A~%" (white "mod") mod)
                     (equal? (format #f "~A" m-name)
                             (format #f "~A" (car mod))))
                   pkg-modules)))
        (format #t "~A: ~A~%" (white "found file") file)
        file))

(define (-find-m-file-in-pkg-structs arg pkg)
  (format #t "~A: ~A~%" (blue "find-m-file-in-pkg-structs") arg)
  (let* ((statics (if-let ((files (assoc-in '(:structures :static) pkg)))
                          (cdr files) '()))
         (_ (format #t "~A: ~A~%" (yellow "statics") statics))
         (dynamics (if-let ((files (assoc-in '(:structures :dynamic) pkg)))
                           (cdr files) '()))
         (_ (format #t "~A: ~A~%" (yellow "dynamics") dynamics))
         (structs (concatenate statics dynamics))
         (_ (format #t "~A: ~A~%" (yellow "structs") structs))
         (file
          (find-if (lambda (struct)
                     (format #t "~A: ~A~%" (white "struct") struct)
                     (equal? (format #f "~A" arg)
                             (format #f "~A" (cdr struct))))
                   structs)))
        (format #t "~A: ~A~%" (white "found file") file)
        file))

(define (-find-m-file-in-pkg-sigs arg pkg)
  (format #t "~A: ~A~%" (blue "find-m-file-in-pkg-sigs") arg)
  (let* ((pkg-sigs (if-let ((files (assoc-val :signatures pkg)))
                              files '()))
         (_ (format #t "~A: ~A~%" (yellow "pkg-sigs") pkg-sigs))
         (file
          (find-if (lambda (sig)
                     (format #t "~A: ~A~%" (white "sig") sig)
                     (equal? (format #f "~A" arg)
                             (format #f "~A" (cdr sig))))
                   pkg-sigs)))
        (format #t "~A: ~A~%" (white "found file") file)
        file))

;; returns pair from :modules, :structures, or :signatures
;; e.g. (:ml foo.ml) or (Foo . foo.ml) or (Foo . foo.mli)
(define (find-m-file-in-pkg arg pkg)
  (format #t "~A: ~A~%" (blue "find-file-in-pkg-files") arg)
  ;; (format #t "~A: ~A~%" (blue ":files") (assoc-val :files pkg))
  ;; (format #t "~A: ~A~%" (blue "deps") deps)
  ;; (format #t "~A: ~A~%" (red ":scripts") (assoc-val :scripts pkg))

  (if-let ((m (-find-m-file-in-pkg-modules arg pkg)))
          m
          (if-let ((m (-find-m-file-in-pkg-structs arg pkg)))
                  m
                  (if-let ((m (-find-m-file-in-pkg-sigs arg pkg)))
                          m))))

(define (is-module-in-pkg m pkg)
  (format #t "~A: ~A~%" (cyan "is-module-in-pkg") m)
  (let* ((pkg-mods (if-let ((files (assoc-val :modules pkg)))
                             (map car files) '()))
         (_ (format #t "~A: ~A~%" (yellow "pkg-mods") pkg-mods))
         (pkg-structs (if-let ((files (assoc-val :structures pkg)))
                           (map car (car (map cdr files)))
                           '()))
         (_ (format #t "~A: ~A~%" (yellow "pkg-structs") pkg-structs))
         (pkg-sigs (if-let ((files (assoc-val :signatures pkg)))
                           (map car (car (map cdr files)))
                           '()))
         (_ (format #t "~A: ~A~%" (yellow "pkg-sigs") pkg-sigs))
         (modules (concatenate pkg-mods pkg-structs pkg-sigs)))
    (member m modules)
    ))

;;FIXME: rename
;; may update deps
(define (find-file-in-pkg-files!? arg deps pkg)
  (format #t "~A: ~A~%" (blue "find-file-in-pkg-files") arg)
  (format #t "~A: ~A~%" (blue ":files") (assoc-val :files pkg))
  (format #t "~A: ~A~%" (blue "deps") deps)
  ;; (format #t "~A: ~A~%" (red ":scripts") (assoc-val :scripts pkg))

  (if (assoc-val :files pkg)
      (let* ((pkg-files (if-let ((files (assoc-val :files pkg)))
                                files '()))
             (pkg-files (append
                         (if-let ((statics (assoc-val :static pkg-files)))
                                 statics '())
                         (if-let ((dynamics (assoc-val :dynamic pkg-files)))
                                 dynamics '())))
             (_ (format #t "~A: ~A~%" (cyan "pkg-files") pkg-files))
             (file
              (find-if (lambda (f)
                         (format #t "~A: ~A~%" (white "f") f)
                         (equal? (format #f "~A" arg)
                                 (format #f "~A" f)))
                       pkg-files)))
        (format #t "~A: ~A~%" (white "found file") file)
        (if file
            #t
            ;; update deps/targets but no dups
            ;; (let ((key (string->keyword (format #f "~A" arg))))
            ;;   (format #t "~A: ~A~%" (magenta "FOUND ~A in :files") file)
            ;;   (set-cdr! deps (cons (cons key
            ;;                              (list (cons :pkg (assoc-val :pkg-path pkg))
            ;;                                    (cons :tgt arg)))
            ;;                        (cdr deps)))
            ;;   key)

            ;; else not found in :files
            ;; if it looks like a filename, add it
            (begin
              (if (string-index (format #f "~A" arg)
                                (lambda (ch) (equal? ch #\/)))
                  #f ;; skip if not in this pkg
                  (begin
                    (set! pkg (update-pkg-files! pkg (list arg)))
                    #t)))))
      ;; else no :files field; add it
      (begin
        (set! pkg (update-pkg-files! pkg (list arg)))
        #t #|(string->keyword (format #f "~A" arg))|# )))

(define (-codept-pkg-file-deps pkg-path)
  (format #t "~A: ~A~%" (blue "-codept-pkg-file-deps") pkg-path)
  (let* ((fpath (format #f "~A/*" pkg-path)) ;; (cdr struct)))
         (cmd (format #f "codept -k -expand-deps -sexp -I ~A ~A/*"
                      pkg-path pkg-path))
         (_ (format #t "~A: ~A~%" (green "cmd") cmd)))
    (let ((deps (string-trim '(#\newline) (system cmd #t))))
      (format #t "~A: ~A~%" (yellow "codept") deps))
  ;;(set-cdr! struct (cdr struct))
    ))

(define (-ocamldep-pkg-file-deps pkg)
  (format #t "~A: ~A~%" (blue "-ocamldep-pkg-file-deps") pkg)
  (let* ((pkg-path (car (assoc-val :pkg-path pkg)))
         (fpath (format #f "~A/*" pkg-path)) ;; (cdr struct)))
         (cmd (format #f "ocamldep -one-line -modules -I ~A ~A/*"
                      pkg-path pkg-path))
         (_ (format #t "~A: ~A~%" (green "cmd") cmd)))
    (let* ((deps (string-trim '(#\newline) (system cmd #t)))
           (deps (string-split deps #\newline)))
      (for-each (lambda (dep)
                  ;; (format #t "~A: ~A~%" (yellow "ocamldep") dep)
                  (let ((segs (string-split dep #\:)))
                    ;; (format #t "~A: ~A~%" (yellow "segs") segs)
                    (if (null? (cdr segs))
                        (begin)
                        (let* ((fpath (car segs))
                               (fname (basename fpath))
                               (kind (filename->kind fname))
                               (mdeps (string-trim '(#\space) (cadr segs)))
                               (mdeps (string-split mdeps #\space))
                               (mdeps (map string->symbol mdeps))
                               ;; eliminate mdeps not in this pkg
                               (mdeps (filter (lambda (d) (is-module-in-pkg d pkg)) mdeps))
                               )
                          (format #t "~A: ~A~%" (yellow "ocamldep fname") fname)
                          (format #t "~A: ~A~%" (yellow "ocamldep kind") kind)
                          (format #t "~A: ~A~%" (yellow "ocamldep mdeps") mdeps)
                          (if-let ((m-assoc (find-m-file-in-pkg fname pkg)))
                                  (begin
                                    (format #t "~A: ~A~%" (red "m-assoc in pkg") m-assoc)
                                    (if (proper-list? m-assoc)
                                        ;; its a module entry, (A (:ml a.ml) (:mli a.mli))
                                        (set-cdr! m-assoc
                                                  (append (cdr m-assoc)
                                                          (list (cons
                                                                 (if (eq? kind :struct)
                                                                     :ml-deps :mli-deps)
                                                                 mdeps))))
                                        ;; else its a struct entry, (A a.ml)
                                        (set-cdr! m-assoc
                                                  (cons (cdr m-assoc)
                                                        mdeps))))
                                      )))))
                deps))
    ))

(define (-resolve-pkg-struct-deps pkg-path pkg-structs)
  (format #t "~A: ~A~%" (blue "-resolve-pkg-struct-deps") pkg-structs)
  (let* ((statics (if-let ((statics (assoc-val :static pkg-structs)))
                          statics '()))
         (dynamics (if-let ((dynamics (assoc-val :dynamics pkg-structs)))
                           dynamics '()))
         (structs (concatenate statics dynamics)))
    (format #t "~A: ~A~%" (green "statics") statics)
    (format #t "~A: ~A~%" (green "dynamics") dynamics)
    (format #t "~A: ~A~%" (green "structs") structs)
    (for-each (lambda (struct)
                (format #t "~A: ~A~%" (green "s") struct)
                (let* ((fname (cdr struct))
                       (fpath (format #f "~A/*" pkg-path)) ;; (cdr struct)))
                       (cmd (format #f "codept -k -expand-deps -sexp -I ~A ~A"
                                    pkg-path fpath))
                       ;; (cmd (format #f "ocamldep -one-line -modules ~A" fpath))
                       (_ (format #t "~A: ~A~%" (green "cmd") cmd))
                       (deps (string-trim '(#\newline) (system cmd #t))))
                  (format #t "~A: ~A~%" (yellow "ocamldeps") deps))
                  ;;(set-cdr! struct (cdr struct))
                  )
              structs)))

;; for each pkg file (module, sig, struct),
;;   find the stanza that depends on it
;;   if depending stanza is namespaced, continue
;;   else ocamldep and update the pkg fld with :deps
(define (resolve-pkg-file-deps ws)
  (format #t "~A: ~A~%" (blue "resolve-pkg-file-deps") ws)
  (let* ((@ws (assoc-val ws -mibl-ws-table))
         (pkgs (car (assoc-val :pkgs @ws))))
    (for-each (lambda (kv)
                (let* ((pkg-path (car kv))
                       (pkg (cdr kv))
                       (_ (format #t "~A: ~A~%" (green "pkg-path") pkg-path))
                       (_ (format #t "~A: ~A~%" (green "pkg") pkg))
                       (pkg-modules (if-let ((ms (assoc-val :modules pkg)))
                                            ms '()))
                       (pkg-structs (if-let ((structs (assoc-val :structures pkg)))
                                            structs '()))
                       (pkg-sigs (if-let ((sigs (assoc-val :signatures pkg)))
                                                      (car sigs) '())))
                (format #t "~A: ~A~%" (green "pkg-modules") pkg-modules)
                (format #t "~A: ~A~%" (green "pkg-structs") pkg-structs)
                (format #t "~A: ~A~%" (green "pkg-sigs") pkg-sigs)
                ;; (-resolve-pkg-module-deps pkg-modules)
                ;; (-resolve-pkg-struct-deps pkg-path pkg-structs)))
                ;; (-resolve-pkg-sig-deps pkg-sigs)
                ;; (-codept-pkg-file-deps pkg-path)))
                (-ocamldep-pkg-file-deps pkg)))
              pkgs)))
