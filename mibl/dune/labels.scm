(define (-fixup-progn-cmd! ws c targets deps)
  (format #t "~A: ~A\n" (blue "-fixup-progn-cmd!") c)
  c)

(define (-fixup-stanza! ws stanza)
  (format #t "~A: ~A\n" (blue "-fixup-stanza!") stanza)
  (let* ((exports (car (assoc-val :exports ws)))
         (stanza-alist (cdr stanza)))
    (format #t "~A: ~A\n" (green "fixup hidden exports tbl") exports)
    (case (car stanza)
      ((:ns-archive)
       (format #t "~A~%" (magenta "fixup :ns-archive"))
       (let ((deps (assoc-val :deps stanza-alist)))
         (format #t "ns-archive deps: ~A~%" deps)))

      ((:archive)
       (format #t "~A~%" (magenta "fixup :archive"))
       (let ((deps (assoc-val :deps stanza-alist)))
         (format #t "archive deps: ~A~%" deps)))

      ((:library)
       (format #t "~A~%" (magenta "fixup :library"))
       (let ((deps (assoc-val :deps stanza-alist)))
         (format #t "library deps: ~A~%" deps)))

      ((:executable)
       (format #t "~A~%" (magenta "fixup :executable"))
       ;; FIXME: also handle :dynamic
       (let ((deps (assoc-in '(:compile :deps :fixed) stanza-alist)))
         (format #t "exec deps: ~A~%" deps)
         (if (not (null? deps))
             (let ((new (map (lambda (dep)
                               (format #t "dep: ~A\n" dep)
                               (let ((exp (hash-table-ref exports dep)))
                                 (format #t "val: ~A\n" exp)
                                 (format #f "//~A:~A" exp dep)))
                             (cdr deps))))
               (set-cdr! deps new)))
               ))

      ((:rule)
       (format #t "~A: ~A~%" (magenta "fixup :rule") stanza-alist)
       (let* ((targets (assoc-val :outputs stanza-alist))
              (_ (format #t "targets: ~A~%" targets))
              (deps (if-let ((deps (assoc-val :deps stanza-alist)))
                            (if (null? deps) '() (car deps))
                            '()))
              (_ (format #t "deps: ~A~%" deps))
              (action (if-let ((action (assoc-val :actions stanza-alist)))
                              action
                              (if-let ((action
                                        (assoc-val :progn stanza-alist)))
                                      action
                                      (error 'bad-action "unexpected action in :rule"))))
              (_ (format #t "action: ~A~%" action))
              (tool (assoc-in '(:actions :cmd :tool) stanza-alist)))
         (format #t "Tool: ~A~%" tool)
         (format #t "Action: ~A~%" action)
         (format #t "stanza-alist: ~A~%" stanza-alist)

         ;; :actions is always a list of cmd; for progn, more than one
         (if (assoc :actions stanza-alist)
             (begin
               (for-each (lambda (c)
                           (format #t "PROGN cmd: ~A~%" c)
                           (-fixup-progn-cmd! ws c targets deps))
                         action))
             ;; else? actions always have a :cmd?
             (begin
               (format #t "rule action: ~A~%" action)
               (format #t "rule tool: ~A~%" tool)
               (format #t "rule targets: ~A~%" targets)
               (format #t "rule deps: ~A~%" deps)
               (error 'unhandled action "unhandled action")
               ;; (if-let ((tool-label (hash-table-ref exports (cadr tool))))
               ;;         (let* ((_ (format #t "tool-label: ~A~%" tool-label))
               ;;                (pkg (car (assoc-val :pkg tool-label)))
               ;;                (tgt (car (assoc-val :tgt tool-label)))
               ;;                (label (format #f "//~A:~A" pkg tgt))
               ;;                (_ (format #t "tool-label: ~A\n" tool-label)))
               ;;           (set-cdr! tool (list label)))
               ;;         ;; FIXME: handle deps
               ;;         '())
               ))))

      (else
       (error 'fixme (format #f "-fixup-stanza! unhandled stanza: ~A\n" (car stanza)))))))

;; updates stanzas
(define resolve-labels!
  (let ((+documentation+ "Map dune target references to bazel labels using exports table.")
        (+signature+ '(resolve-labels! workspace)))
    (lambda (ws)
      (format #t "~A for ws: ~A\n" (blue "resolve-labels!") ws)
              ;; (assoc-val 'name ws))
      (let* ((pkgs (car (assoc-val :pkgs ws)))
             ;; (_ (format #t "PKGS: ~A\n" pkgs))
             (exports (car (assoc-val :exports ws))))
        ;; (format #t "resolving labels for pkgs: ~A\n" (hash-table-keys pkgs))
        ;; (format #t "exports: ~A\n" exports)
        (for-each (lambda (kv)
                    (format #t "resolving pkg: ~A~%" (car kv))
                    ;; (format #t "pkg: ~A~%" (cdr kv))
                    (if-let ((stanzas (assoc-val :dune (cdr kv))))
                            (for-each (lambda (stanza)
                                        (-fixup-stanza! ws stanza)
                                        (format #t "stanza: ~A~%" stanza))
                                      stanzas))
                    )
                  pkgs)
        ))))

